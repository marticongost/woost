<?xml version="1.0" encoding="utf-8"?>

<?py
from itertools import chain
from cocktail.modeling import extend, call_base
from cocktail.iteration import is_empty
from cocktail.schema import Reference
from cocktail.controllers.viewstate import view_state
from cocktail.controllers.userfilter import CollectionFilter
from cocktail.html.datadisplay import DataDisplay
from cocktail.html.shortcuts import set_translated_shortcut
from sitebasis.models import Item, Site, reduce_ruleset
from sitebasis.views.contenttypetree import ContentTypeTree
from sitebasis.controllers.backoffice.useractions import \
    add_view_action_context
?>

<py:cocktail.html.CollectionView
    xmlns="http://www.w3.org/1999/xhtml"
    xmlns:py="http://www.whads.com/ns/cocktail/templates">

    <?py
    self.add_resource("/cocktail/scripts/jquery.js")
    self.add_resource("/resources/scripts/ContentView.js")    
    self.add_client_translation("sitebasis.views.ContentView advanced search title")
    self.add_client_translation("sitebasis.views.ContentView show advanced search")
    self.add_client_translation("sitebasis.views.ContentView close advanced search")
    self.add_client_translation("sitebasis.views.ContentView search button")
    
    add_view_action_context(self, "content_view")
    ?>

    <?py-class
    collection_params = None
    available_content_views = ()
    visible_languages = ()
    root_content_type = Item
    edit_stack = None
    member = None
    activation_control = ".show_detail_action"
    
    @classmethod
    def get_collection(cls, content_type, item = None, relation = None):
        if item:
            return item.get(relation)
        else:
            return None # default

    @classmethod
    def compatible_with(cls, content_type, item = None, relation = None):
        return True
    
    def _attach(self, controller):
        pass

    def _init_user_collection(self, user_collection):
        pass
        
    def get_new_content_uri(self, content_type):
        params = {
            "type": content_type.name,
            "edit_stack": self.edit_stack.to_param() if self.edit_stack else None
        }
        
        if self.member:
            params["member"] = self.member.name

        return self.cms.document_uri('content', 'new', **params)        

    def content_type_is_instantiable(self, content_type):
        return content_type.visible \
            and content_type.instantiable \
            and self.cms.authorization.allows(
                target_type = content_type,
                action = "create",
                partial_match = True
            )

    excluded_view_state_params = \
        CollectionView.excluded_view_state_params | frozenset(["rel"])
    ?>

    <py:with py:element="self.filters">
        <py:ready>
            <py:with py:element="self.filters_selector"
                py:if="hasattr(self, 'filters_selector')">
                <py:with py:def="filter_ui" py:args="filter">
                    <?py
                    @extend(element)
                    def get_default_member_display(element, obj, member):
                        if isinstance(member, Reference):
                            if member.class_family is not None:
                                display = templates.new("sitebasis.views.ContentTypePicker")
                                display.root = member.class_family
                                return display
                            elif not (
                                isinstance(filter, CollectionFilter)
                                and filter.member.edit_inline
                            ):
                                return "sitebasis.views.ItemSelector"
                    
                        return call_base(obj, member)
                    ?>
                </py:with>
            </py:with>
        </py:ready>
    </py:with>

    <py:ready>

        <py:with py:element="self.collection_display"
            py:filters="${self.user_collection.user_filters}">
            <?py
            ruleset = reduce_ruleset(
                Site.main.access_rules_by_priority,
                {
                    "user": self.cms.user,
                    "action": "read",
                    "target_type": self.user_collection.type
                }
            )
            cms_allows = self.cms.allows
            element.authorization_check = lambda **ctx: cms_allows(ruleset = ruleset, **ctx)

            if isinstance(element, DataDisplay):
                element.set_member_label("element", translations(self.user_collection.type.name))
            ?>
        </py:with>

        <?py
        self.set_client_param("persistencePrefix", self.user_collection.persistence_prefix)

        if self.user_collection.user_filters:
            user_filter = self.user_collection.user_filters[0]
            if user_filter.id == "global_search":                
                self.set_client_param("searchQuery", user_filter.value)
        
        self._instantiable_content_types = set(
            content_type
            for content_type in chain(
                [self.user_collection.type],
                self.user_collection.type.derived_schemas()
            )
            if self.content_type_is_instantiable(content_type)
        )            
        ?>
    </py:ready>
    
    <py:block
        py:index="0">

        <div py:id="content_type_box">

            <py:ready>
                <?py
                content_type = self.user_collection.type

                if content_type is self.root_content_type \
                and not any(
                    derived_schema.visible
                    for derived_schema in content_type.derived_schemas(recursive = False)
                ):
                    element.visible = False
                ?>
            </py:ready>

            <div class="label">${translations("sitebasis.views.ContentView content type")}</div>
            
            <!-- Content type selector -->
            <py:sitebasis.views.ContentTypeSelector
                py:id="content_type_selector"
                py:value="@{self.user_collection.type}"
                py:root="@{self.root_content_type}">

                <py:with py:def="tree"
                    py:plural_labels="${True}"
                    py:selection="${self.user_collection.type}">
                    <?py
                    @extend(tree)
                    def create_entry(tree, content_type):
                        entry = call_base(content_type)
                        if content_type is self.user_collection.type:
                            entry.add_class("selected")
                        return entry

                    @refine(tree)
                    def filter_item(tree, content_type):
                        return (
                            ContentTypeTree.filter_item(tree, content_type)
                            and self.cms.authorization.allows(
                                    target_type = content_type,
                                    action = "read",
                                    partial_match = True
                                )
                        )
                    
                    @refine(tree)
                    def get_item_url(tree, content_type):
                        url = "?type=" + content_type.__name__
                        if self.edit_stack:
                            url += "&edit_stack=" + self.edit_stack.to_param()
                        return url
                    ?>
                </py:with>

            </py:sitebasis.views.ContentTypeSelector>
        </div>

        <!-- Content view selector -->
        <div py:id="content_view"
            class="action_button">

            <span py:id="content_view_label">
                ${translations("sitebasis.views.ContentView label")}
            </span>

            <py:cocktail.html.LinkSelector
                py:id="content_view_selector"
                py:name="content_view">

                <?py
                @refine(element)
                def get_item_label(self, content_view):                    
                    return translations(content_view.content_view_id + " content view")
                
                @refine(element)
                def get_item_value(self, content_view):
                    return content_view.content_view_id
                ?>

                <py:with
                    py:def="entry_link" py:args="value, label"
                    title="${label}">
                    <?py element.empty() ?>
                    <img src="/resources/images/${value.lower()}contentview.png"/>
                </py:with>

            </py:cocktail.html.LinkSelector>

            <py:ready>
                <?py
                if self.available_content_views \
                and len(self.available_content_views) > 1:                    
                    self.content_view_selector.items = self.available_content_views
                    self.content_view_selector.value = self
                else:
                    self.content_view.visible = False
                ?>
            </py:ready>
        </div>

    </py:block>

    <!-- Toolbar -->
    <py:sitebasis.views.ActionBar
        py:def="toolbar"
        py:action_context="toolbar"
        py:action_target="@{self.user_collection.type}"
        py:empty_result_set="@{not self.visible_results}">
        <?py
        @extend(toolbar)
        def get_actions(toolbar, context):
            actions = call_base(context)
            if not self._instantiable_content_types:
                actions = [action for action in actions if action.id not in ("new", "add_integral")]
            return actions

        @extend(toolbar)
        def create_action_button(toolbar, action, extra):
            if action.id in ("new", "add_integral"):
                if len(self._instantiable_content_types) > 1:
                    button = self.create_new_toolbar_button(action, extra)
                else:
                    button = call_base(action, extra)
                    button.tag = "a"
                    del button["name"]
                    button["href"] = self.get_new_content_uri(list(self._instantiable_content_types)[0])
            else:
                button = call_base(action, extra)
            
            button.set_client_param("minSelection", action.min)
            button.set_client_param("maxSelection", action.max)
            return button
        ?>
    </py:sitebasis.views.ActionBar>

    <!-- New item selector -->
    <div py:def="new_toolbar_button"
        py:args="action, extra"
        class="selector action_button new">
        <span class="label">
            <?py
            set_translated_shortcut(element, "action " + action.id)
            ?>
            <py:new
                py:element="self.toolbar.create_action_image(action, extra)"
                py:if="self.toolbar.button_images and not extra"/>
            ${translations("Action " + action.id)}
        </span>
        <div class="selector_content">
            <py:sitebasis.views.ContentTypeTree
                py:id="new_item_selector"
                py:root="@{self.user_collection.type}">
        
                <?py
                @refine(element)
                def filter_item(new_item_selector, content_type):
                    return content_type in self._instantiable_content_types

                @refine(element)
                def get_item_url(new_item_selector, content_type):
                    return self.get_new_content_uri(content_type)
                ?>
            </py:sitebasis.views.ContentTypeTree>
        </div>
    </div>

    <py:sitebasis.views.ActionBar
        py:id="list_buttons"
        py:button_images="${False}"
        py:action_context="list_buttons"
        py:action_target="@{self.user_collection.type}"
        class="buttons"/>

</py:cocktail.html.CollectionView>
