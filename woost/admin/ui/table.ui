<?xml version="1.0" encoding="utf-8"?>

<ui:cocktail.ui.Table
    xmlns="http://www.w3.org/1999/xhtml"
    xmlns:ui="http://www.whads.com/ns/cocktail/ui"
    tabindex="0"
    selectionType="multiple"
    sortable="true">

    <ui:using mixin="woost.admin.ui.ObjectSource"/>
    <ui:symbol name="SET_AUTOEXPAND"/>

    <ui:property
        name="listing"
        reflected="false"
        final="true">

        <?on changed
        cocktail.ui.link(newValue, this, "model");
        cocktail.ui.link(newValue, this, "empty");
        cocktail.ui.link(newValue, this, ["members", "visibleMembers"]);
        cocktail.ui.link(newValue, this, ["locales", "visibleLocales"]);
        cocktail.ui.link(newValue, this, "order");
        cocktail.ui.link(newValue, this, "resultCount");
        newValue.selectable = this;
        ?>

    </ui:property>

    <?class
    createRow(record) {
        const row = super.createRow(record);
        row.draggable = true;
        return row;
    }

    resolveObjectSourceTarget(e) {
        for (let element of e.path) {
            if (element.classList && element.classList.contains("cocktail-ui-Table-Row")) {
                return element;
            }
        }
        return null;
    }

    getDataSourceOptions(page) {

        const options = super.getDataSourceOptions(page);
        const listing = this.listing;

        if (listing.view) {
            options.url = listing.view.dataURL;
            options.parameters.model = this.model.originalMember.name;
        }

        if (listing.partition) {
            options.parameters.partition = listing.navigationNode.queryParameters.partition.serializeValue(listing.partition);
        }

        if (listing.search) {
            options.parameters.search = listing.search;
        }

        if (listing.order) {
            options.parameters.order = listing.order;
        }

        if (listing.filters.length) {
            Object.assign(
                options.parameters,
                cocktail.navigation.node.getQueryValuesForFilters(listing.filters)
            )
        }

        if (listing.relation) {
            let owner = listing.relationOwner;
            if (owner && !owner._new) {
                options.parameters.relation = `${owner.id}-${listing.relation.name}`;
            }
            else {
                options.parameters.relation = listing.relation.fullName;
            }
        }

        return options;
    }

    async invalidation(changes) {

        // TODO: invalidation of hierarchical tables
        // TODO: invalidation animations (collapse removed rows, pulse new / modified rows)

        // Remove the rows representing deleted objects
        for (let [id, object] of changes.deleted) {
            const row = this.getRowById(id);
            if (row) {
                row.parentNode.removeChild(row);
            }
        }

        // Update the rows representing modified objects
        for (let [id, object] of changes.modified) {
            const row = this.getRowById(id);
            if (row) {
                row.value = object;
            }
        }

        // Create a map to index all created/modified objects
        const stateIndex = {};
        for (let objectMap of [changes.created, changes.modified]) {
            for (let [id, object] of objectMap) {
                stateIndex[id] = object;
            }
        }

        // Query the server to determine which rows should be added,
        // repositioned or removed
        const options = this.getDataSourceOptions(this.page);
        options.url += "/ids";

        const data = await this.value.load(options);
        const newListingContents = data.objects;
        this.resultCount = data.count;

        // Identify objects that should be in the new listing state, but
        // have no preexisting row and haven't been created or modified
        // in this invalidation (example use case: top up the current page
        // up to the pagination size after rows are deleted)
        const missing = [];
        for (let id of newListingContents) {
            if (!this.getRowById(id) && !stateIndex[id]) {
                missing.push(id);
            }
        }

        // Load missing state
        if (missing.length) {

            const options = this.getDataSourceOptions(this.page);
            if (!options.parameters) {
                options.parameters = {};
            }
            options.requiresPOST = true;
            options.parameters.subset = missing.join(" ");

            const missingData = await this.value.load(options);

            for (let object of missingData.records) {
                stateIndex[object.id] = object;
            }
        }

        // Iterate over the new row values for the listing
        let currentRow = this.body.firstChild;

        for (let id of newListingContents) {

            // Preexisting row at the correct spot; do nothing
            if (currentRow && id == currentRow.getAttribute("value")) {
                currentRow = currentRow.nextSibling;
            }
            // Mismatch
            else {
                const object = stateIndex[id];
                let row = this.getRowById(id);

                // Reposition an existing row
                if (row) {
                    if (currentRow) {
                        currentRow.insertAdjacentElement("beforebegin", row);
                    }
                    else {
                        this.body.appendChild(row);
                    }
                }
                // Create a new row
                else if (object) {
                    this.addRow(object, currentRow ? {before: currentRow} : null);
                }
            }
        }

        // Strip remaining rows: they exist no longer in the listing (they don't
        // match the active filters, partition or search string, or have fallen
        // below the current pagination window
        while (currentRow) {
            const nextRow = currentRow.nextSibling;
            this.body.removeChild(currentRow);
            currentRow = nextRow;
        }
    }

    [SET_AUTOEXPAND]() {

        if (this.listing.search) {
            this.autoExpand = true;
            return;
        }

        if (this.searchSchema && this.searchValues) {
            for (let member of this.searchSchema.members()) {
                let value = this.searchValues[member.name];
                if (value !== null && value !== undefined && value !== "") {
                    this.autoExpand = true;
                    return;
                }
            }
        }

        this.autoExpand = false;
    }
    ?>

    <?on listingReset
    this[SET_AUTOEXPAND]();
    this.sortable = this.listing.view.allows_sorting;
    this.paging = this.listing.view.pagination ? "infiniteScroll" : "none";
    this.treeRelations = this.listing.view.tree_relations;
    this.reset();
    ?>

    <ui:cocktail.ui.Table.TreeRow ui:component="TreeRow">

        <ui:property
            name="treeFiltersMatch"
            type="string"
            reflected="true"/>

        <?class
        getRowLabel() {
            return this.translateValue();
        }
        ?>

        <?on value:changed
        this.treeFiltersMatch = newValue._match;
        ?>

    </ui:cocktail.ui.Table.TreeRow>

</ui:cocktail.ui.Table>

