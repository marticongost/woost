<?xml version="1.0" encoding="utf-8"?>

<ui:element
    xmlns="http://www.w3.org/1999/xhtml"
    xmlns:ui="http://www.whads.com/ns/cocktail/ui"
    selectableEntriesSelector=".Row"
    selectionType="multiple"
    appliesAlternateCSSClasses="true"
    tabindex="0">

    <ui:using mixin="cocktail.ui.Selectable"/>

    <ui:symbol name="DROP_HIGHLIGHTED_ELEMENT"/>
    <ui:symbol name="PLACE_INSERTION_MARKER"/>
    <ui:symbol name="CLEAR_INSERTION_MARKER"/>
    <ui:symbol name="INSERTION_MARKER"/>
    <ui:symbol name="SELECTABLE_ID_MAP"/>

    <ui:property
        name="item"
        reflected="false">
        <?on changed
        this.blocksTreeRoot.item = newValue;
        ?>
    </ui:property>

    <ui:property
        name="hoverRow"
        reflected="false">
        <?on changed
        if (oldValue) {
            oldValue.hover = false;
        }
        if (newValue) {
            newValue.hover = true;
        }
        ?>
    </ui:property>

    <?class
    createSlotDisplay(item, slot, depth = 0, isSingleSlot = false) {
        const slotDisplay = this.constructor.SlotDisplay.create();
        slotDisplay.blocksTree = this;
        slotDisplay.depth = depth;
        slotDisplay.item = item;
        slotDisplay.slot = slot;
        slotDisplay.isSingleSlot = isSingleSlot;
        slotDisplay.update();
        return slotDisplay;
    }

    createBlockDisplay(block, depth = 0) {
        const display = this.constructor.BlockDisplay.create();
        display.blocksTree = this;
        display.depth = depth;
        display.item = block;
        this[SELECTABLE_ID_MAP][display.selectableId] = display;
        return display;
    }

    get selectionContainer() {
        return this.blocksTreeRoot;
    }

    resolveSelectableId(selectableId) {
        return this[SELECTABLE_ID_MAP][selectableId];
    }

    getSlotDisplay(container, slot) {
        const containerId = typeof(container) == "object" ? container.id : block;
        const slotName = typeof(slot) == "string" ? slot : slot.name;
        return this.resolveSelectableId(`slot-${containerId}-${slotName}`);
    }

    getSlotRow(container, slot) {
        const slotDisplay = this.getSlotDisplay(container, slot);
        return slotDisplay && slotDisplay.row;
    }

    getBlockDisplay(block) {
        const blockId = typeof(block) == "object" ? block.id : block;
        return this.resolveSelectableId(`block-${blockId}`);
    }

    getBlockRow(block) {
        const blockDisplay = this.getBlockDisplay(block);
        return blockDisplay && blockDisplay.row;
    }

    includeInEvenOddSequence(element) {
        return !element.slotInfo;
    }

    newBlock(blockType, placement, target, params = null) {

        const locales = params && params.locales;

        return blockType.newInstance(locales).then((block) => {
            return this.placeBlocks(
                [block],
                placement,
                target,
                Boolean(params && params.focus)
            )[0];
        });
    }

    placeBlocks(blocks, placement, target, focus = false) {

        const newBlocks = [];
        const movedBlocks = [];
        const blockDisplays = [];

        if (placement == "after" || placement == "before") {
            blocks = Array.from(blocks);
            blocks.reverse();
        }

        for (let block of blocks) {
            let blockDisplay = this.getBlockDisplay(block.id);
            let slotDisplay;
            let prevSlotDisplay;

            if (placement == "inside") {
                // Appending to a slot
                if (target.slotInfo) {
                    slotDisplay = target.slotDisplay;
                }
                // Appending to a block with a single slot
                else {
                    slotDisplay = this.getSlotDisplay(target.value, target.implicitSlot);
                }
            }
            else {
                slotDisplay = target.slotDisplay;
            }

            if (blockDisplay) {
                block = blockDisplay.item;
                prevSlotDisplay = blockDisplay.slotDisplay;
                const blocksArray = prevSlotDisplay.item[prevSlotDisplay.slot.name];
                blocksArray.splice(blockDisplay.blockIndex, 1);
                blockDisplay.remove();
            }
            else {
                blockDisplay = this.createBlockDisplay(block, slotDisplay.depth);
            }

            const blocksArray = slotDisplay.item[slotDisplay.slot.name];

            if (placement == "inside") {
                slotDisplay.slotBlocks.appendChild(blockDisplay);
                blocksArray.push(block);
            }
            else {
                const targetDisplay = target.blockDisplay;
                const sibling = placement == "after" ? targetDisplay.nextSibling : targetDisplay;

                if (!sibling) {
                    blocksArray.push(block);
                }
                else {
                    blocksArray.splice(sibling.blockIndex, 0, block);
                }

                slotDisplay.slotBlocks.insertBefore(blockDisplay, sibling);
            }

            blockDisplay.depth = slotDisplay.depth;

            if (prevSlotDisplay) {
                const info = {
                    block: block,
                    previousLocation: {
                        display: prevSlotDisplay,
                        container: prevSlotDisplay.item,
                        slot: prevSlotDisplay.slot
                    },
                    newLocation: {
                        display: slotDisplay,
                        container: slotDisplay.item,
                        slot: slotDisplay.slot
                    },
                    placement,
                    target,
                    focus
                };
                movedBlocks.push(info);
                cocktail.ui.trigger(this, "blockMoved", info);
            }
            else {
                const info = {
                    block: block,
                    display: slotDisplay,
                    container: slotDisplay.item,
                    slot: slotDisplay.slot,
                    focus: focus
                };
                newBlocks.push(info);
                cocktail.ui.trigger(this, "newBlock", info);
            }

            blockDisplays.push(blockDisplay);
        }

        cocktail.ui.trigger(this, "blocksPlaced", {newBlocks, movedBlocks});
        return blockDisplays;
    }

    deleteBlocks(blocks) {

        const locationsMap = {};
        const locationsList = [];

        for (let block of blocks) {
            const blockDisplay = this.getBlockDisplay(block.id);
            const slotDisplay = blockDisplay.slotDisplay;

            // Group delete operations, to emit a single event at the end
            let locationInfo = locationsMap[slotDisplay.selectableId];
            if (!locationInfo) {
                locationInfo = {
                    container: slotDisplay.item,
                    slot: slotDisplay.slot,
                    blocks: []
                };
                locationsMap[slotDisplay.selectableId] = locationInfo;
                locationsList.push(locationInfo);
            }
            locationInfo.blocks.push(block);

            // Remove the object from its container
            const blocksArray = slotDisplay.item[slotDisplay.slot.name];
            blocksArray.splice(blocksArray.indexOf(block), 1);

            // Remove the entry in the tree
            blockDisplay.remove();
        }

        if (blocks.length) {
            cocktail.ui.trigger(this, "blocksDeleted", {
                locations: locationsList
            });
        }
    }

    [PLACE_INSERTION_MARKER](row, placement) {

        let marker = this[INSERTION_MARKER];
        if (!marker) {
            marker = this.constructor.InsertionMarker.create();
            this[INSERTION_MARKER] = marker;
            this.shadowRoot.appendChild(marker);
        }

        let x, y;

        if (placement == "before") {
            x = row.icon.offsetLeft;
            y = row.offsetTop;
        }
        else if (placement == "after") {
            x = row.icon.offsetLeft;
            const blockDisplay = row.blockDisplay;
            y = blockDisplay.offsetTop + blockDisplay.offsetHeight;
        }
        else if (placement == "inside") {
            x = (row.slotHeading || row.descriptionLabel).offsetLeft;
            const slotDisplay = row.childrenSlotDisplay;
            y = slotDisplay.offsetTop + slotDisplay.offsetHeight;
        }

        if (this[DROP_HIGHLIGHTED_ELEMENT]) {
            this[DROP_HIGHLIGHTED_ELEMENT].classList.remove("dropHighlightedTarget");
        }

        if (placement == "inside") {
            this[DROP_HIGHLIGHTED_ELEMENT] = row;
        }
        else {
            this[DROP_HIGHLIGHTED_ELEMENT] = row.parentRow;
        }

        this[DROP_HIGHLIGHTED_ELEMENT].classList.add("dropHighlightedTarget");

        marker.style.left = `${x}px`;
        marker.style.top = `${y}px`;
    }

    [CLEAR_INSERTION_MARKER]() {
        if (this[INSERTION_MARKER]) {
            this[INSERTION_MARKER].remove();
            this[INSERTION_MARKER] = null;
        }
        if (this[DROP_HIGHLIGHTED_ELEMENT]) {
            this[DROP_HIGHLIGHTED_ELEMENT].classList.remove("dropHighlightedTarget");
        }
    }

    getSlotForPlacement(row, placement) {

        if (placement == "inside") {
            if (row.slotInfo) {
                return row.slotInfo.member;
            }
            return row.implicitSlot;
        }

        return row.slotDisplay.slot;
    }
    ?>

    <?on-window dragend
    this[CLEAR_INSERTION_MARKER]();
    ?>

    <?js
    this[SELECTABLE_ID_MAP] = {};
    ?>

    <ui:BlocksContainer id="blocksTreeRoot">
        <?js
        element.blocksTree = this;
        element.isBlocksTreeRoot = true;
        ?>
    </ui:BlocksContainer>

    <div ui:component="Row">

        <ui:using mixin="woost.admin.ui.ObjectDropArea"/>
        <ui:symbol name="..PLACE_INSERTION_MARKER"/>
        <ui:symbol name="..CLEAR_INSERTION_MARKER"/>

        <ui:property
            name="hover"
            type="boolean"
            reflected="true"
            default="false"/>

        <?class
        get nextRow() {
            return null;
        }

        get parentRow() {
            let element = this.parentNode;
            while (element) {
                if (element.row && element.row !== this) {
                    return element.row;
                }
                element = element.parentNode;
            }
            return null;
        }

        objectDraggedOver(e) {
            let [row, placement] = this.resolveDropEvent(e);
            this.parentInstance[PLACE_INSERTION_MARKER](row, placement);
        }

        resolveDropEvent(e) {

            const rect = this.getBoundingClientRect();
            const y = e.pageY - rect.top;
            const relPosition = y / rect.height;

            let row = this;
            let placement = this.getDropPlacement(relPosition);

            // Prevent slight movements of the insertion marker by normalizing
            // to 'before' when moving up/down along consecutive blocks in a slot
            if (placement == "after") {
                let nextRow = this.nextRow;
                if (nextRow) {
                    row = nextRow;
                    placement = "before";
                }
            }

            return [row, placement];
        }

        getDropPlacement(relPosition) {
            return "inside";
        }

        acceptsDrop(data) {

            // Accept only blocks
            if (!data.model.isSchema(woost.models.Block)) {
                return false;
            }

            // Reject blocks from other subsets
            const [targetRow, placement] = this.resolveDropEvent(data.event);
            const slot = this.parentInstance.getSlotForPlacement(targetRow, placement);

            if (!data.model.blockSubsets.includes(slot.subset)) {
                return false;
            }

            // Prevent a block from being placed inside / next to itself
            let row = targetRow;
            while (row) {
                if (row.value && row.value.id == data.item.id) {
                    return false;
                }
                row = row.parentRow;
            }

            return true;
        }

        objectDropped(data) {
            const [row, placement] = this.resolveDropEvent(data.event);
            this.parentInstance.placeBlocks([data.item], placement, row);
        }
        ?>

        <?on mouseenter
        this.parentInstance.hoverRow = this;
        ?>

        <?on mouseleave
        this.parentInstance.hoverRow = null;
        ?>

    </div>

    <div ui:component="BlocksContainer">

        <ui:symbol name="..SELECTABLE_ID_MAP"/>

        <ui:property
            name="item"
            reflected="false">
            <?on changed
            const model = newValue._class;
            const slots = [];
            for (let member of model.members()) {
                if (member instanceof woost.models.Slot) {
                    slots.push(member);
                }
            }
            cocktail.ui.empty(this.slotsList);
            for (let slot of slots) {
                const slotDisplay = this.blocksTree.createSlotDisplay(
                    newValue,
                    slot,
                    this.isBlocksTreeRoot ? 0 : this.depth + 1,
                    slots.length == 1
                );
                this.slotsList.appendChild(slotDisplay);
                this.blocksTree[SELECTABLE_ID_MAP][slotDisplay.selectableId] = slotDisplay;
            }
            ?>
        </ui:property>

        <ui:property
            name="depth"
            type="number"
            reflected="true"
            default="0">
            <?on changed
            this.style.setProperty("--depth", newValue);
            ?>
        </ui:property>

        <div id="slotsList"/>

    </div>

    <div ui:component="SlotDisplay">

        <ui:symbol name="..SELECTABLE_ID_MAP"/>

        <ui:property
            name="selectableId"
            type="string"
            reflected="true"/>

        <ui:property
            name="item"
            reflected="false"/>

        <ui:property
            name="slot"
            reflected="false"/>

        <ui:property
            name="depth"
            type="number"
            reflected="true"
            default="0">
            <?on changed
            this.style.setProperty("--depth", newValue);
            ?>
        </ui:property>

        <ui:property
            name="isSingleSlot"
            type="boolean"
            reflected="true"
            default="false"/>

        <?class
        get blockDisplay() {
            return cocktail.ui.closestInstance(this, woost.admin.ui.BlocksTree.BlockDisplay);
        }

        get objectPath() {
            const blockDisplay = this.blockDisplay;
            return blockDisplay ? blockDisplay.objectPath + "-" + this.slot.name : this.slot.name;
        }

        clear() {
            cocktail.ui.empty(this);
        }

        update() {
            this.selectableId = `slot-${this.item.id}-${this.slot.name}`;
            if (!this.depth || !this.isSingleSlot) {
                this.row = cls.SlotRow.create();
                this.row.slotInfo = {member: this.slot, container: this.item};
                this.slotBlocks.parentNode.insertBefore(this.row, this.slotBlocks);
            }
            cocktail.ui.empty(this.slotBlocks);
            const blocks = this.item[this.slot.name];
            for (let block of blocks) {
                this.addBlock(block);
            }
        }

        addBlock(block) {
            const display = this.blocksTree.createBlockDisplay(block, this.depth);
            this.slotBlocks.appendChild(display);
            return display;
        }
        ?>

        <div id="slotBlocks"/>

        <ui:woost.admin.ui.BlocksTree.Row ui:component="SlotRow">

            <ui:property
                name="slotInfo"
                reflected="false">
                <?on changed
                this.slotHeading.innerHTML = newValue.member.translate();
                ?>
            </ui:property>

            <?class
            get slotDisplay() {
                return cocktail.ui.closestInstance(this, woost.admin.ui.BlocksTree.SlotDisplay);
            }

            get childrenSlotDisplay() {
                return this.slotDisplay;
            }

            get selectableId() {
                const slotDisplay = this.slotDisplay;
                return slotDisplay && slotDisplay.selectableId;
            }
            ?>

            <div id="slotHeading"/>

        </ui:woost.admin.ui.BlocksTree.Row>

    </div>

    <ui:BlocksContainer ui:component="BlockDisplay">

        <ui:property
            name="selectableId"
            type="string"
            reflected="true"/>

        <ui:property
            name="disabledBlock"
            type="boolean"
            reflected="true"
            default="false"/>

        <?class
        get slotDisplay() {
            return cocktail.ui.closestInstance(this, woost.admin.ui.BlocksTree.SlotDisplay);
        }

        get blockIndex() {
            if (!this.parentNode) {
                return -1;
            }
            return Array.from(this.parentNode.children).indexOf(this);
        }

        get objectPath() {
            const slotDisplay = this.slotDisplay;
            const blockIndex = this.blockIndex;
            if (slotDisplay && blockIndex != -1) {
                return slotDisplay.objectPath + "-" + blockIndex;
            }
            return "";
        }
        ?>

        <ui:BlockRow id="row" ui:placement="before slotsList"/>

        <?on item:changed
        const blockType = newValue._class;
        this.selectableId = `block-${newValue.id}`;
        this.disabledBlock = !newValue.enabled;
        if (!this.row.dataBinding) {
            this.row.dataBinding = {
                member: new cocktail.schema.Reference({type: blockType}),
                value: newValue
            };
        }
        else {
            this.row.value = newValue;
        }
        ?>

        <ui:woost.admin.ui.BlocksTree.Row
            ui:component="BlockRow"
            contextMenuEnabled="false">

            <ui:using mixin="woost.admin.ui.ObjectSource"/>

            <?head
            const BLOCK_DROP_BEFORE_RATIO = 0.5;
            const CONTAINER_DROP_BEFORE_RATIO = 0.3;
            const CONTAINER_DROP_AFTER_RATIO = 0.7;
            ?>

            <?class
            get blockDisplay() {
                return cocktail.ui.closestInstance(this, woost.admin.ui.BlocksTree.BlockDisplay);
            }

            get slotDisplay() {
                return cocktail.ui.closestInstance(this, woost.admin.ui.BlocksTree.SlotDisplay);
            }

            get blockIndex() {
                const blockDisplay = this.blockDisplay;
                return blockDisplay && blockDisplay.blockIndex;
            }

            get nextRow() {
                const blockDisplay = this.blockDisplay;
                return blockDisplay && blockDisplay.nextSibling && blockDisplay.nextSibling.row;
            }

            get selectableId() {
                const blockDisplay = this.blockDisplay;
                return blockDisplay && blockDisplay.selectableId;
            }

            get objectPath() {
                const blockDisplay = this.blockDisplay;
                return blockDisplay && blockDisplay.objectPath;
            }

            get implicitSlot() {
                const blockType = this.value._class;
                const slots = [];
                for (let member of blockType.members()) {
                    if (member instanceof woost.models.Slot) {
                        slots.push(member);
                    }
                    if (slots.length > 1) {
                        break;
                    }
                }
                return slots.length == 1 ? slots[0] : null;
            }

            get childrenSlotDisplay() {
                return this.blockDisplay.slotsList.firstChild;
            }

            getDropPlacement(relPosition) {
                if (this.implicitSlot) {
                    if (relPosition <= CONTAINER_DROP_BEFORE_RATIO) {
                        return "before";
                    }
                    else if (relPosition >= CONTAINER_DROP_AFTER_RATIO) {
                        return "after";
                    }
                    else {
                        return "inside";
                    }
                }
                else {
                    if (relPosition <= BLOCK_DROP_BEFORE_RATIO) {
                        return "before";
                    }
                    else {
                        return "after";
                    }
                }
            }
            ?>

            <ui:using mixin="cocktail.ui.DataDisplay"/>

            <?on value:changed
            const blockType = newValue._class;
            this.icon.src = blockType[woost.admin.ui.modelIconURL];
            this.descriptionLabel.innerHTML = blockType.translateValue(newValue);
            this.typeLabel.innerHTML = blockType.translate();
            ?>

            <ui:cocktail.ui.SVG id="icon"/>

            <div id="blockInfo">
                <div id="descriptionLabel"/>
                <div id="typeLabel"/>
            </div>

        </ui:woost.admin.ui.BlocksTree.Row>

    </ui:BlocksContainer>

    <div ui:component="InsertionMarker"/>

</ui:element>

